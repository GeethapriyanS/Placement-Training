ğŸ”¹ Merge Sort
ğŸ“Œ Approach: Divide and Conquer
ğŸ“Œ Process:

Recursively splits the array into two halves until each sub-array has one element.
Merges sorted sub-arrays back together.
ğŸ“Œ Time Complexity:

Best case: ğ‘‚(ğ‘› log ğ‘›)
Average case: ğ‘‚(ğ‘› log ğ‘›)
Worst case: ğ‘‚(ğ‘› log ğ‘›)
ğŸ“Œ Space Complexity: ğ‘‚(ğ‘›) (Requires extra space for merging)
ğŸ“Œ Stable?: âœ… Yes (Maintains relative order of equal elements)
ğŸ“Œ Best Used For: Large datasets, linked lists, external sorting (files on disk).

ğŸ”¹ Quick Sort
ğŸ“Œ Approach: Divide and Conquer
ğŸ“Œ Process:

Picks a pivot element and partitions the array into elements smaller and larger than the pivot.
Recursively sorts the sub-arrays.
ğŸ“Œ Time Complexity:

Best case: ğ‘‚(ğ‘› log ğ‘›)
Average case: ğ‘‚(ğ‘› log ğ‘›)
Worst case: ğ‘‚(ğ‘›Â²) (When the worst pivot is chosen)
ğŸ“Œ Space Complexity: ğ‘‚(log ğ‘›) (In-place sorting, only recursive stack memory)
ğŸ“Œ Stable?: âŒ No (Relative order of equal elements may change)
ğŸ“Œ Best Used For: Large datasets, when space is a concern, and when a good pivot strategy is used.